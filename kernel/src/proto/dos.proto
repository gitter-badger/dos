package dos;

// the global rpc status
enum RpcStatus {
  // make rpc successfully
  kRpcOk = 0;
  // fail to prepare rootfs
  kRpcPrepareRootfsFailed = 1;
  // container name or job name exists
  kRpcNameExist = 2;
  kRpcError = 3;
}

message User {
  optional int32 uid = 1;
  optional string name = 2;
  optional int32 gid = 3;
  optional uint64 ctime = 4;
}


// resource related descriptor
message Cpu {
  optional uint32 limit = 1;
  optional uint32 share = 2;
  optional uint32 used = 3;
}

message Memory {
  optional uint64 limit = 1;
  optional uint64 used = 2;
}

message Range {
  optional uint32 start = 1;
  optional uint32 end = 2;
}

message Port {

  repeated uint32 ports = 1;
  // port_name will be assigned real port and inject it into enviroment 
  // with same name
  repeated string port_names = 2;

  optional Range range = 3;
}

message Network {
  optional uint32 in_bytes_ps = 1;
  optional uint32 out_bytes_ps = 2;
}

message DiskIO {
  optional uint32 read_bytes_ps = 1;
  optional uint32 write_bytes_ps = 2;
  optional string device = 3;
}

// the resource for service run time
message Resource {
  optional Cpu cpu = 1;
  optional Memory memory = 2;
  optional Port port = 3;
  optional Network network = 4;
  optional DiskIO diskio = 5;
}

message Process {
  repeated string args = 1;
  optional User user = 2;
  repeated string envs = 3;
  optional string cwd = 4;
  optional string pty = 5;
  optional bool running = 6;
  optional int32 pid = 7;
  optional int32 gpid = 8;
  // the process start to run time point
  optional int64 rtime = 9;
  optional bool coredump = 10;
  optional int32 exit_code = 11;
  optional string name = 12;
  optional bool terminal = 13;
}

message Platform {
  optional string os = 1;
  optional string arch = 2;
}

message Root {
  optional string path = 1;
  optional bool readonly = 2;
}

message Mount {
  optional string name = 1;
  optional string path = 2;
  optional string type = 3;
  optional string source = 5;
  optional string destination = 6;
  repeated string options = 7;
}

message Device {
  optional string path = 1;
  optional int32 type = 2;
  optional int32 major = 3;
  optional int32 minor = 4;
  optional string permissions = 5;
  optional int32 mode = 6;
  optional int32 uid = 7;
  optional int32 gid = 8;
}

enum NodeState {
  kNodeNormal = 0;
  kNodeOffline = 1;
  kNodeFrozen = 2;
}

message NodeMeta {
  optional string ip = 1;
  optional string hostname = 2;
  optional string endpoint = 3;
  optional Resource resource = 4;
  optional NodeState state = 5;
}

enum ContainerType {
  // use system rootfs
  kSystem = 0;
  // use docker image
  kDocker = 1;
  // use oci rootfs
  kOci = 2;
}

message Container {
  optional Resource requirement = 1;
  // opencontainer format or docker image
  optional string image = 2;
  optional string tag = 3;
  // the image download url
  optional string uri = 4;
  optional ContainerType type = 5;
  optional bool enable_ns = 6;
  // no process related with it
  optional bool reserved = 7;
}

message PodSpec {
  repeated Container containers = 1;
}

message JobSpec {
  optional string name = 1;
  optional uint32 replica = 2;
  optional uint32 deploy_step_size = 3;
  optional uint32 update_step_size = 4;
}

message NodeStatus {
  optional string endpoint = 1;
  optional string hostname = 2;
  optional Resource used = 3;
  optional NodeState state = 4;
  optional int64 task_id = 5;
}

enum ContainerState {
  kContainerPending = 0;
  // pull image from image server
  kContainerPulling = 1;
  // start initd process
  kContainerBooting = 2;
  // run container task command
  kContainerRunning = 3;
  // task exit with 0
  kContainerCompleted = 4;
  // task was killed -9
  kContainerKilled = 5;
  // when main process exit, the container can be remained
  kContainerReserved = 6;
  // the end state when some errors happened
  kContainerError = 7;
}

message ContainerStatus {
  optional string name  = 1;
  optional int64 start_time = 2;
  optional Resource used = 3;
  optional ContainerState state = 4;
}
